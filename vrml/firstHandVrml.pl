#!/usr/bin/perl -w
#
# firstHandVrml.pl

# Calculates the coordinates and faces for the first hand model 
# Constructs model by projecting the reciprical spiral onto a torus
# The torus has a circular cross section
#
# Prints a proper vrml file to stdout
#
# Jonah Bossewitch
# $Header: /home/users/jonah/cvs/handy/perl/firstHandVrml.pl,v 1.1 2001/08/14 04:01:52 jonah Exp $
#

use strict;

my $PI = 3.145;

# some model constants
my $span = $PI / 6; 
my $EPSILON = 0.1;  
my $EPSILON_FINE = 0.01;
my $inner = 0.6;    # the radius of the inner circle
my $outer = 0.025;  # the radis of the indide of the  whole torus


my @coords = &createHand($inner, $outer);
my @faces = &generateFaces(scalar @coords);

# print "Content-type: model-vrml\n\n";

print <<"VRML_HEADER";
#VRML V1.0 ascii
#
# This file defines the Meru Foundations FirstHand model in vrml
# It has been generated by a script, so please do not edit by hand
#

DEF FirstHand Separator {

# scale up since calculations are done on small values
Scale { 
     scaleFactor 3 3 3
} 

ShapeHints { 
   shapeType UNKNOWN_SHAPE_TYPE
}

VRML_HEADER

print "Coordinate3 {\n\t point [ \n\t";
print join(",\n\t", @coords);
print "\n  ]\n} \n";

print "IndexedFaceSet { coordIndex [\n\t";
print join(",\n\t", @faces);
print "\n  ]\n}\n";

print "}\n";  # close the separator

#
# createHand
# Generate the points for the spiral hand
# returns a list of coordinate3 point strings
#
sub createHand {
    my ($inner, $outer) = @_;

    my @coords = ();
    my $SHIFT = 0.0;  # this is unused for now
    my ($r, $theta, $x, $y, $z, $epsilon);
    my $orientation = 1.0;

    my $first = 1;
    my ($v1, $v2, $v3, $v4); # really just strings to hold each vertext


#    Vector handPoints = new Vector(); // initial cap.
    $epsilon = $EPSILON;

    # Reciprocal spiral:  r = 1/theta.
    # Standard Torus Equation: f(u,v) = [ (a + b*cos(v))*cos(u),
    #                                    (a + b*cos(v))*sin(u),
    #                                     c*sin(v) ]
    #
    for ($theta = ((3 * $PI) + 2); $theta > 0; $theta -= $epsilon) {
	if ($theta < 1) {  # increase resolution as we approach the origin
	    $epsilon = $EPSILON_FINE;
	}
	$r = 1/($theta);
	$x = $r * cos($theta);
	$z = $r * sin($theta);


	$y = abs(($inner * $inner) - 
		 ( ($r - ($inner + $outer)) * ($r - ($inner + $outer)) ));
	if ($y > $EPSILON_FINE) {
	    $y = $orientation * sqrt($y);
	}
	elsif ($r < $SHIFT) {
	    $y = 0;
	}
	else {
	    # Abandon ship when y becomes imaginary
	    push(@coords, $v1);
	    push(@coords, $v2);
	    push(@coords, "$x 0 $z");
	    $x = $r * cos($theta + $span);
	    $z = $r * sin($theta + $span);
	    push(@coords, "$x 0 $z");

	    last;
	}

	# First time through start at origin
	if ($first) {
	    $v3 = "$x 0.0 $z";
	    $v4 = "$x 0.0 $z";
	    $first = 0;
	}
	else {
	    $v3 = $v1;
	    $v4 = $v2;
	}

	$v1 = "$x $y $z";

	$x = $r * cos($theta + $span);
	$z = $r * sin($theta + $span);

	$v2 = "$x $y $z";

	push (@coords, $v1);
	push (@coords, $v2);
	push (@coords, $v3);
	push (@coords, $v4);
    }
    return @coords;
}

#
# generateFaces
# returns a list of the triangular faces that the coordinates describe
#
sub generateFaces {
    my $vertexCount = shift;
    my @faces = ();
    for (my $i = 0; $i < ($vertexCount - 3); $i++) {
	my $v1 = $i;
	my $v2 = $i + 1;
	my $v3 = $i + 2;
	my $v4 = $i + 3;
	# create two rectangles so its shaded from both sides
	push (@faces, "$v1, $v3, $v2, -1"); 
	push (@faces, "$v2, $v3, $v1, -1"); 
	push (@faces, "$v2, $v3, $v4, -1"); 
	push (@faces, "$v4, $v3, $v2, -1"); 

    }
    return @faces;
}
